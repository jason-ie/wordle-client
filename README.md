# TCP/TLS Wordle Client Project

## Introduction

This project features a **Node.js-based** client for a Wordle-like word guessing game. The primary purpose of the client is to interact with a remote game server, engaging in a word-guessing challenge modeled after the popular Wordle game. The client establishes a network connection with the server, either using a _standard TCP protocol_ or a _secured TLS protocol_, based on user preference. Once connected, the client participates in the game by sending guesses for a hidden word to the server. Each guess is a five-letter word, submitted as a JSON-formatted message. In response, the server provides feedback for each guess, indicating which letters are correct and in the right position, which are correct but in the wrong position, and which are not in the word at all.

Throughout the game, the client handles various types of messages from the server, including initial setup _(hello, start)_, ongoing game communication _(guess, retry)_, and game conclusion _(bye)_. The game concludes once the correct word is guessed, upon which the server sends a unique flag as a form of completion acknowledgment. This project showcases the integration of network programming concepts, JSON message handling, and algorithmic problem-solving, culminating in a functional and interactive game client.

## High-Level Approach

The client application's development focused on establishing robust network communication with the game server and implementing a strategic guessing logic. Utilizing Node.js, the project leverages the net and tls modules for TCP and TLS connections, respectively. A key aspect of the approach was to parse and construct _JSON messages_ for interaction with the server, adhering to the game's protocol. The client's guessing strategy is driven by an algorithm that filters potential words based on server feedback, dynamically adjusting the list of possible guesses. The design emphasizes modularity and efficient handling of server responses to enhance the gameplay experience.

## Challenges Faced

A key challenge was managing repeated letters in guesses, particularly when the server provides mixed marks for the same letter. For example, lets say the secret word we are trying to guess is **"light"**. Let's also say that the client sends the word "hello" as its guess to the server. The server would then return the array [1, 0, 1, 0, 0] as the proper marks for the gues **"hello"**. This creates confusion since typically, a **0** at a certain letter would indicate that the particular letter doesn't exist in the word. Initially, I removed all words with letters given a **0**, but when dealing with a word with more than one of the same letter, like **"hello"**, and the client realizes that the second **"l"** has a **0** assigned to it, it would remove all words containing an **"l"**, including the actual word of **"light"**. To fix this, I implemented another phase of filtering where words with double letters wouldn't be removed when the filtering occurred. This ensured that words with double letters wouldn't be skipped, allowing the client to eventually reach the correct end result and guess the correct word.

## Guessing Strategy

The client's guessing strategy is engineered around an intelligent word-filtering algorithm. Starting with a comprehensive list of potential words, the client refines this list after each guess based on the server's feedback. It systematically eliminates words that do not match the criteria of letter presence and position indicated by the server. This strategy not only focuses on pinpointing the correct word efficiently but also adapts to the complexity introduced by repeated letters and varying server hints, ensuring a logical and targeted approach to each guess. An example of a filtering method I used was whenever a **1** appeared in the marks array. Since we know this letter is in the word, we can now remove all words that don't have this letter in them. We also know that the word cannot have the assigned letter in a particular position, so we can also remove all words that have the assigned letter at that particular position. This is how the client filters the word list to eventually have one remaining word.

## Testing Methodology

Testing encompassed simulating server responses under various scenarios, including challenging cases with repeated letters and mixed marks. The project involved writing unit tests for the filtering logic and conducting thorough end-to-end testing with the game server to ensure comprehensive functionality. The main way I tested my client source code was by writing statements to the console, ensuring that every variable I created was correctly assigned to what I thought it was, every if-statement correctly checked the what I thought it did, and every dynamic variable was correctly updated in the right spot. `console.log()` statements allowed me to see my code through every step of the way and better understand **client to server and server to client responses.**

## Conclusion

Completing this project has been a rewarding journey that combined network programming, strategic algorithm development, and real-time data processing. It presented unique challenges, particularly in handling complex game logic and ensuring effective communication with the server. The success of the client in accurately guessing words in a Wordle-like game environment demonstrates the robustness of the underlying strategy and code. This experience has not only strengthened technical skills in JavaScript and Node.js but also provided valuable insights into problem-solving and software design principles.
